#!/usr/bin/env bash
#===================================================================================
# LABADMIN SCRIPT SERVER AGENT FOR LINUX
#         FILE: labadmin-script_server_agent
#  DESCRIPTION: Labadmin script server client agent for Linux hosts
#
#       AUTHOR: Leonardo Marco (labadmin@leonardomarco.com)
#	   LICENSE: GNU General Public License v3.0
#      VERSION: 2026.02
#      CREATED: 2022.06.28
#=================================================================================== 


#===============================================================================
#  LOAD GLOBAL CONFIG
#===============================================================================
readonly agent_path="$(dirname "$(readlink -f "$0")")"					# Agent installed path
source "${agent_path}/config"

#===============================================================================
#  GLOBAL VARIABLES
#===============================================================================
readonly hostname=$(hostname)											# Hostname
readonly sshcmd="/opt/labadmin-script_server/lss-srv"					# Labadmin script server command path in remote server
readonly agent_version=$(cat "${agent_path}/version" 2>/dev/null)		# Agent version
readonly log_file="${log_path}/log"                                     # Log file where save action logs
readonly scripts_path="${log_path}/scripts"                             # Log directory where save scripts and exec logs




#=== FUNCTION ==================================================================
#        NAME: log
# DESCRIPTION: write in log file using format: [DATETIME] [ACTION]  EXEC_MSG
#===============================================================================
function log() {
	local action="$1"
	local script="$2"
	local exec_msg="$3"

	action_width=11
	action="[${action^^}]$(seq -s" " 1 $(($action_width-${#action}))|tr -d "[0-9]")"
	[ "$script" ] && script="[$script]"

	log_msg="[$(date "+%Y-%m-%d %H:%M:%S")] ${action} ${script}"
	[[ "$action" = *LIST* ]] && log_msg="└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n${log_msg}"
	if [[ "$action" = *EXEC* ]]; then
		log_msg="${log_msg} -> '${exec_msg}'"
	else
		exec_msg="    ${exec_msg//$'\n'/$'\n    '}"      # Add spaces at begining each line
		log_msg="${log_msg}\n${exec_msg}"
	fi
	[[ "$action" = *LIST* ]] && log_msg="${log_msg}\n"
	echo -e "${log_msg}" >> "$log_file"
}


#=== FUNCTION ==================================================================
#        NAME: call_script_server
# DESCRIPTION: call ssh labadmin_script-server manager
# PARAMETERS:
#	$1 	action
#	$2 	script
#	$3 	exec_msg
#===============================================================================
function call_script_server() {
	local action="$1"
	local script="$2"
	local exec_msg="$3"

	# Args array
	args=()
	[ -n "$action" ]        && args+=(-a "$action")
	[ -n "$script" ]        && args+=(-s "$script")
	[ -n "$exec_msg" ]      && args+=(-m "$exec_msg")
	[ -n "$agent_version" ] && args+=(-v "$agent_version")

	# Save remote command scaped en remote_cmd variable
	printf -v remote_cmd '%q ' bash "$sshcmd" -h "$hostname" -M "$mac" -r "$repository" "${args[@]}"

	# SSH exec
	ssh 2>&1 -n -T -i "$sshprivatekey_path" "${sshuser}@${sshaddress}" -p "$sshport" "$remote_cmd"

	return $?
}


#=== FUNCTION ==================================================================
#        NAME: wait_connection
# DESCRIPTION: wait until server connection is active
#===============================================================================
function wait_connection() {
	n=10	# Number of tries
	d=10	# Delay in seconds in each time

	for i in $(seq 1 $n); do
		nc -z "$sshaddress" "$sshport" &>/dev/null && return 0
		echo "Waiting for server connection..."
		sleep $d
	done
	echo -e "\e[1m\e[31mTimeout waiting for server connection\e[0m"
	exit 1
}




#=== FUNCTION ==================================================================
#        NAME: initialize
# DESCRIPTION: performs init checks
#===============================================================================
function initialize() {
	# CHECK ROOT
	if [ ! "$UID" -eq 0 ]; then
		echo -e "\e[1m\e[31mMust be exec with administrative privileges\e[0m"
		exit 1
	fi

	# CHECK LOG PATH
	[ -f "$log_path" ] && rm -f "$log_path"
	[ ! -d "$log_path" ] && mkdir -p "$log_path" 
	[ ! -d "$scripts_path" ] && mkdir -p "$scripts_path" 
	
	# CHECK SSH PRIVATE KEY
	if ! ssh-keygen -l -f "$sshprivatekey_path" 1>/dev/null; then
		echo -e "\e[1m\e[31mError loading SSH agent private key: $sshprivatekey_path\e[0m"
		exit 1
	fi
	
	# WAIT CONNECTION
	wait_connection

	# GET DEFAULT MAC ADDRESS
	mac=$(ip -c=never addr show dev $(ip -c=never -o -4 route get "8.8.8.8" | egrep -o "dev ([[:alnum:]])*" | awk '{print $2}') | grep link/ether | awk '{print $2}')
	if [ $? -ne 0 ] || [ "${mac#[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]}" ]; then
		echo -e "\e[1m\e[31mError getting local MAC address $MAC\e[0m"
		exit 1		
	fi
}



#=== FUNCTION ==================================================================
#        NAME: main
# DESCRIPTION: main code
#===============================================================================
function main() {
	# INIT
	initialize

	# GET PENDING SCRIPT LIST
	echo -e "\e[1mGETTING PENDING SCRIPT LIST\e[0m"
	call_output=$(call_script_server "list")
	if [ $? -ne 0 ]; then
		echo -e "\e[1m\e[31mError getting pending scripts list\e[0m"
		echo "$call_output"
		log "list_error" "" "$call_output"
		exit 1
	fi
	script_list="$call_output"
	log "list_ok" "" "$script_list"
	if [ ! "$script_list" ]; then
		echo "0 pending scripts"
		exit 0
	fi
	echo -e "$(echo "$script_list" | sed 's/\//\t\//' | column -t -s $'\t' | sed 's/\//\\e[0m\//' | sed 's/^/  \\e\[1m\\e\[33m/')\e[0m"

	# GET AND EXEC SCRIPTS
	IFS2="$IFS"; IFS=$'\n';
	for script in $script_list; do
		# GET SCRIPT OPTIONS
		unset opt_nosavelog; [[ "${script,,}" = */nosavelog* ]] && opt_nosavelog="true"		# Get NOSAVELOG option
		script_opts="${script#${script%%/*}}"												# Script options -> text after first /
		script="${script%%/*}"       														# Clean script name -> delete all after / 
		script=${script%"${script##*[![:space:]]}"}											# Script name trim spaces

		# HEADER
		printf '\n┌'; printf '─%.0s' $(seq 1 $((COLUMNS-2))); printf '┐\n'; echo -e "\033[1A\033[5C \e[1m\e[33m$script\e[0m "

		# GET SCRIPT CODE
		script_code=$(call_script_server "get" "$script")
		if [ $? -ne 0 ]; then
			echo -e "\e[1m\e[31mERROR GETTING SCRIPT CODE: $script\e[0m"
			echo "$script_code"
			log "get_error" "$script" "$script_code"
			continue
		fi

		# SAVE SCRIPT
		script_path="${scripts_path}/[$(date "+%Y-%m-%d_%H.%M.%S" | tr "/:" "-.")][EXEC_XX] ${script//\// }"
		script_log="${script_path}.log"
		script_path="${script_path}.sh"
		echo "$script_code" > "$script_path" || { echo -e "\e[1m\e[31mERROR SAVING SCRIPT: ${script_path}\e[0m"; log "save_error" "$script"; continue; }
		[ "$script_opts" ] && echo -e "\e[1mSCRIPT OPTS\e[0m: $script_opts"
		echo -e "\e[1mSCRIPT FILE\e[0m: '$script_path'"
		echo -e "\e[1mOUTPUT FILE\e[0m: '$script_log'"

		# EXEC SCRIPT
		echo -e "\e[1m\nEXECUTION SCRIPT\e[0m"
		bash "$script_path" | tee "$script_log"
		exec_code=${PIPESTATUS[0]}
		exec_msg=$(cat "$script_log")

		# RENAME SCRIPT FILE AND LOG ADDING [EXEC_CODE] TO FILENAME
		if [ "$opt_nosavelog" ]; then				# Option NOSAVELOG -> remove script file and log
			rm -f "$script_log" "$script_path"
			script_log="NOSAVELOG"
		else
			[ $exec_code -eq 0 ] && ec="EXEC_OK" || ec="EXEC_ER"
			script_path_old="$script_path"; script_log_old="$script_log"
			script_path="${script_path//\[EXEC_XX\]/[$ec]}"
			script_log="${script_log//\[EXEC_XX\]/[$ec]}"
			mv "$script_path_old" "$script_path"
			mv "$script_log_old" "$script_log"
		fi

		# SEND EXIT CODE TO SERVER AND LOG
		if [ $exec_code -eq 0 ]; then
			log "exec_ok" "$script" "$script_log"
			call_script_server "exec_ok" "$script" "$exec_msg"
		else
			echo -e "\e[1m\e[31mERROR EXECUTING SCRIPT: $script\e[0m"
			log "exec_error" "$script" "$script_log"
			call_script_server "exec_error" "$script" "$exec_msg"
		fi

		# FOOTER
		printf '└'; printf '─%.0s' $(seq 1 $((COLUMNS-2))); printf '┘\n'; echo -e "\033[1A\033[5C \e[1mEXIT CODE: \e[0m${exec_code} "

	done
	IFS="$IFS2"
	echo
}

main "$@"
